<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>AR 靈異畫像 (JSON版)</title>
    
    <!-- 核心引擎 -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column;
            justify-content: flex-end; align-items: center;
            padding-bottom: 40px;
        }

        .vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 140%);
            z-index: 1;
        }

        .scanline {
            width: 100%; height: 100px; z-index: 2;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(255, 0, 0, 0.1) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute; bottom: 100%;
            animation: scanline 8s linear infinite;
        }

        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100%; }
        }
    </style>
</head>
<body style="margin: 0px; overflow: hidden;">

    <!-- 螢幕特效層 -->
    <div class="vignette"></div>
    <div class="scanline"></div>
    
    <!-- UI 提示文字 -->
    <div id="ui-layer">
        <div id="status-box" class="bg-black/70 border-l-4 border-red-600 px-6 py-3 text-gray-200 font-mono text-center transition-all duration-300">
            <h2 id="ui-title" class="text-xl font-bold text-red-500">讀取中...</h2>
            <p id="ui-desc" class="text-sm mt-1">正在載入設定檔</p>
        </div>
    </div>

    <!-- AR 場景 -->
    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;">
        
        <a-assets>
            <img id="ghost-img" src="" crossorigin="anonymous">
        </a-assets>

        <!-- Marker 將由 JS 動態設定屬性 -->
        <a-marker id="ghost-marker" preset="hiro">
            
            <!-- 靈異圖片疊加層 -->
            <a-image 
                id="overlay-image"
                src="#ghost-img" 
                rotation="-90 0 0" 
                width="1" 
                height="1"
                opacity="0" 
                position="0 0.1 0">
            </a-image>

            <!-- 血光濾鏡 -->
            <a-plane 
                id="blood-plane"
                rotation="-90 0 0" 
                width="1" 
                height="1" 
                color="#880000" 
                opacity="0">
            </a-plane>

        </a-marker>

        <a-entity camera></a-entity>
    </a-scene>

    <script>
        // 宣告全域變數
        let GAME_CONFIG = null;
        let isHaunted = false;
        let glitchInterval;

        // DOM 元素
        const marker = document.querySelector('#ghost-marker');
        const ghostImgElement = document.querySelector('#ghost-img');
        const overlayImage = document.querySelector('#overlay-image');
        const bloodPlane = document.querySelector('#blood-plane');
        const uiTitle = document.querySelector('#ui-title');
        const uiDesc = document.querySelector('#ui-desc');
        const statusBox = document.querySelector('#status-box');

        // 初始化：讀取 config.json
        window.addEventListener('load', () => {
            fetch('config.json')
                .then(response => {
                    if (!response.ok) throw new Error("HTTP error " + response.status);
                    return response.json();
                })
                .then(config => {
                    console.log("設定檔載入成功", config);
                    GAME_CONFIG = config;
                    applyConfig(config);
                    setupEventListeners();
                })
                .catch(err => {
                    console.error("設定檔讀取失敗:", err);
                    uiTitle.innerText = "讀取失敗";
                    uiDesc.innerHTML = "無法讀取 config.json<br>請確認使用 Server 模式開啟";
                    statusBox.classList.remove('border-red-600');
                    statusBox.classList.add('border-yellow-500');
                });
        });

        // 將設定應用到 AR 場景
        function applyConfig(config) {
            // 1. 設定圖片來源
            ghostImgElement.setAttribute('src', config.assets.ghostImage);

            // 2. 設定 Marker 類型
            if (config.assets.markerPreset === 'pattern' && config.assets.markerPatternUrl) {
                marker.setAttribute('preset', 'pattern');
                marker.setAttribute('type', 'pattern');
                marker.setAttribute('url', config.assets.markerPatternUrl);
            } else {
                marker.setAttribute('preset', 'hiro');
            }

            // 3. 設定尺寸與顏色
            overlayImage.setAttribute('width', config.display.width);
            overlayImage.setAttribute('height', config.display.height);
            
            bloodPlane.setAttribute('width', parseFloat(config.display.width) + 0.5); // 血光稍微大一點
            bloodPlane.setAttribute('height', parseFloat(config.display.height) + 0.5);
            bloodPlane.setAttribute('color', config.display.bloodColor);

            // 4. 初始化 UI
            uiTitle.innerText = config.ui.title;
            uiDesc.innerHTML = config.ui.scanningText;
        }

        // 設定事件監聽
        function setupEventListeners() {
            marker.addEventListener('markerFound', () => {
                if(!GAME_CONFIG) return;
                uiDesc.innerHTML = GAME_CONFIG.ui.foundText;
                uiDesc.classList.add('text-red-400', 'font-bold');
                startHaunting();
            });

            marker.addEventListener('markerLost', () => {
                if(!GAME_CONFIG) return;
                uiDesc.innerHTML = GAME_CONFIG.ui.lostText;
                uiDesc.classList.remove('text-red-400', 'font-bold');
                stopHaunting();
            });
        }

        // 啟動靈異效果
        function startHaunting() {
            if (isHaunted || !GAME_CONFIG) return;
            isHaunted = true;

            const effects = GAME_CONFIG.effects;

            // 淡入
            let opacity = 0;
            const fadeIn = setInterval(() => {
                opacity += effects.fadeInSpeed;
                if (opacity >= effects.maxOpacity) clearInterval(fadeIn);
                overlayImage.setAttribute('opacity', opacity);
            }, 100);

            // 故障循環
            glitchInterval = setInterval(() => {
                if (Math.random() > (1 - effects.glitchFrequency)) {
                    // 抖動
                    const jitterX = (Math.random() - 0.5) * effects.jitterAmount;
                    const jitterZ = (Math.random() - 0.5) * effects.jitterAmount;
                    
                    overlayImage.setAttribute('position', `${jitterX} 0.15 ${jitterZ}`);
                    
                    // 隨機變色
                    const randomColor = Math.random() > 0.5 ? '#ffaaaa' : '#ffffff';
                    overlayImage.setAttribute('color', randomColor);
                    
                    // 血光
                    bloodPlane.setAttribute('opacity', Math.random() * effects.bloodIntensity);
                } else {
                    // 恢復
                    overlayImage.setAttribute('position', '0 0.1 0');
                    overlayImage.setAttribute('color', '#ffffff');
                    bloodPlane.setAttribute('opacity', 0);
                }
            }, 100);
        }

        // 停止效果
        function stopHaunting() {
            isHaunted = false;
            clearInterval(glitchInterval);
            overlayImage.setAttribute('opacity', 0);
            overlayImage.setAttribute('position', '0 0.1 0');
            overlayImage.setAttribute('color', '#ffffff');
            bloodPlane.setAttribute('opacity', 0);
        }
    </script>
</body>
</html>